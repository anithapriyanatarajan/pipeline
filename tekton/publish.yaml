apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: publish-release
  annotations:
    chains.tekton.dev/transparency-upload: "true"
spec:
  params:
    - name: package
      description: package to release (e.g. github.com/<org>/<project>)
      default: github.com/tektoncd/pipeline
    - name: images
      description: List of cmd/* paths to be published as images
      default: "controller webhook entrypoint nop workingdirinit resolvers sidecarlogresults events"
    - name: koExtraArgs
      description: Extra args to be passed to ko
      default: "--preserve-import-paths"
    - name: versionTag
      description: Version tag (X.Y.Z for stable, vYYYYMMDD-abc1234 for nightly)
    - name: imageRegistry
      description: The target image registry
      default: ghcr.io
    - name: imageRegistryPath
      description: The path (project) in the image registry
    - name: imageRegistryRegions
      description: The target image registry regions
      default: ""
    - name: imageRegistryUser
      description: Username to be used to login to the container registry
      default: "_json_key"
    - name: releaseAsLatest
      description: Whether to tag and publish this release as Pipelines latest
      default: "true"
    - name: platforms
      description: Platforms to publish for the images (e.g. linux/amd64,linux/arm64)
      default: linux/amd64,linux/arm64,linux/s390x,linux/ppc64le,windows/amd64
    - name: serviceAccountPath
      description: The name of the service account path within the release-secret workspace
  workspaces:
    - name: source
      description: >-
        The workspace where the repo has been cloned. This should ideally
        be /go/src/$(params.package) however that is not possible today,
        see https://github.com/tektoncd/pipeline/issues/3786. To use this
        task on a fork of pipeline change the mountPath below
      mountPath: /go/src/github.com/tektoncd/pipeline
    - name: release-secret
      description: The secret that contains a service account authorized to push to the imageRegistry and to the output bucket
    - name: output
      description: The release YAML will be written to this workspace
  stepTemplate:
    env:
      - name: "PROJECT_ROOT"
        value: "$(workspaces.source.path)"
      - name: CONTAINER_REGISTRY_CREDENTIALS
        value: "$(workspaces.release-secret.path)/$(params.serviceAccountPath)"
      - name: CONTAINER_REGISTRY
        value: "$(params.imageRegistry)/$(params.imageRegistryPath)"
      - name: IMAGE_REGISTRY_PATH
        value: "$(params.imageRegistryPath)"
      - name: CONTAINER_REGISTRY_USER
        value: "$(params.imageRegistryUser)"
      - name: REGIONS
        value: "$(params.imageRegistryRegions)"
      - name: OUTPUT_RELEASE_DIR
        value: "$(workspaces.output.path)/$(params.versionTag)"
      - name: KO_EXTRA_ARGS
        value: "$(params.koExtraArgs)"
      - name: DOCKER_CONFIG_PATH
        value: "$(workspaces.release-secret.path)"
  results:
  # IMAGES result is picked up by Tekton Chains to sign the release.
  # See https://github.com/tektoncd/plumbing/blob/main/docs/signing.md for more info.
  - name: IMAGES
  steps:

  - name: container-registry-auth
    image: cgr.dev/chainguard/crane:latest-dev@sha256:68d9b984ee9cb5ff9cf7a779e8bdf3c2022f9042abfa1f0f5727a082a9429535
    script: |
      #!/bin/sh
      set -ex

      echo ${CONTAINER_REGISTRY_CREDENTIALS}

      # Login to the container registry
      echo "cat before crane login"
      if [[ -f "${CONTAINER_REGISTRY_CREDENTIALS}" ]]; then
        cat "${CONTAINER_REGISTRY_CREDENTIALS}"
      else
        echo "no file"
        echo "workspace path contains ..."
        ls -la /workspace

        echo "workspace release-secret contains ..."
        ls -la /workspace/release-secret

        echo "workspace release-secret/docker-config.json contains ..."
        cat /workspace/release-secret/.dockerconfigjson
      fi

      if [[ ! -f "${CONTAINER_REGISTRY_CREDENTIALS}" ]]; then
        echo "‚ùå Credential file not found: ${CONTAINER_REGISTRY_CREDENTIALS}"
        exit 1
      fi

      DOCKER_CONFIG=$(crane auth login \
        -u "${CONTAINER_REGISTRY_USER}" \
        --password-stdin "$(params.imageRegistry)" \
        < "${CONTAINER_REGISTRY_CREDENTIALS}" 2>&1 | \
        sed -n 's,^.*logged in via \(.*\)$,\1,p')

      if [[ -z "$DOCKER_CONFIG" ]]; then
        echo "‚ùå Failed to retrieve Docker config path from crane login."
        exit 1
      fi

      echo "‚úÖ Logged in successfully. DOCKER_CONFIG: $DOCKER_CONFIG"


      DOCKER_CONFIG=$(cat ${CONTAINER_REGISTRY_CREDENTIALS} | \
        crane auth login -u ${CONTAINER_REGISTRY_USER} --password-stdin $(params.imageRegistry) 2>&1 | \
        sed -n 's,^.*logged in via \(.*\)$,\1,p')

      # Auth with account credentials for all regions.
      for region in ${REGIONS}
      do
        HOSTNAME=${region}.$(params.imageRegistry)
        cat ${CONTAINER_REGISTRY_CREDENTIALS} | crane auth login -u ${CONTAINER_REGISTRY_USER} --password-stdin ${HOSTNAME}
      done

      cat ${DOCKER_CONFIG}

      cp ${DOCKER_CONFIG} /workspace/docker-config.json

      echo "cat /workspace/docker-config.json"
      cat /workspace/docker-config.json

      echo "cat /workspace/release-secret/docker-config.json"
      cat /workspace/release-secret/docker-config.json

  - name: container-registry-auth
    image: cgr.dev/chainguard/crane:latest-dev@sha256:68d9b984ee9cb5ff9cf7a779e8bdf3c2022f9042abfa1f0f5727a082a9429535
    script: |
      #!/bin/sh
      set -ex

      # For GHCR (GitHub Container Registry), handle authentication differently
      if [[ "$(params.imageRegistry)" == "ghcr.io" ]]; then
        echo "üîç Configuring authentication for GitHub Container Registry"

        # For GHCR with Docker registry secrets, the secret structure is different
        # Check if we have a .dockerconfigjson file (from kubectl create secret docker-registry)
        if [[ -f "$(workspaces.release-secret.path)/.dockerconfigjson" ]]; then
          echo "Using Docker registry secret format"
          cp "$(workspaces.release-secret.path)/.dockerconfigjson" /workspace/docker-config.json
        elif [[ -f "${CONTAINER_REGISTRY_CREDENTIALS}" ]]; then
          # Check if it's a docker config.json or a simple token
          if cat ${CONTAINER_REGISTRY_CREDENTIALS} | jq -r '.auths // empty' >/dev/null 2>&1; then
            # It's a docker config.json, copy it directly
            echo "Using docker config.json format"
            cp ${CONTAINER_REGISTRY_CREDENTIALS} /workspace/docker-config.json
          else
            # It's a simple token, create docker config
            echo "Using token-based authentication"
            TOKEN=$(cat ${CONTAINER_REGISTRY_CREDENTIALS})

            # Create docker config for GHCR
            mkdir -p ~/.docker
            echo '{"auths":{"ghcr.io":{"auth":"'$(echo -n "${CONTAINER_REGISTRY_USER}:${TOKEN}" | base64 -w 0)'"}}}' > ~/.docker/config.json
            cp ~/.docker/config.json /workspace/docker-config.json
          fi
        else
          echo "Credentials file not found: ${CONTAINER_REGISTRY_CREDENTIALS}"
          exit 1
        fi
      else
        # Original GCR authentication logic
        echo "üîç Configuring authentication for GCR/other registries"

        # Login to the container registry
        DOCKER_CONFIG=$(cat ${CONTAINER_REGISTRY_CREDENTIALS} | \
          crane auth login -u ${CONTAINER_REGISTRY_USER} --password-stdin $(params.imageRegistry) 2>&1 | \
          sed -n 's,^.*logged in via \(.*\)$,\1,p')

        # Auth with account credentials for all regions.
        for region in ${REGIONS}
        do
          HOSTNAME=${region}.$(params.imageRegistry)
          cat ${CONTAINER_REGISTRY_CREDENTIALS} | crane auth login -u ${CONTAINER_REGISTRY_USER} --password-stdin ${HOSTNAME}
        done
        cp ${DOCKER_CONFIG} /workspace/docker-config.json
      fi

  - name: run-ko
    image: ghcr.io/tektoncd/plumbing/ko@sha256:d21b05e426096c01ea026678a94d019f860e5ba04929b5fd2dd8bb0aaccf31d2
    env:
    - name: KO_DOCKER_REPO
      value: $(params.imageRegistry)/$(params.imageRegistryPath)
    - name: GOFLAGS
      value: "-mod=vendor"
    script: |
      #!/usr/bin/env sh
      set -ex
      
      # Fix Git ownership issue for the repository directory
      git config --global --add safe.directory ${PROJECT_ROOT}

      # Use the generated `.ko.yaml`
      export KO_CONFIG_PATH=/workspace
      cat ${KO_CONFIG_PATH}/.ko.yaml

      # Setup docker-auth
      DOCKER_CONFIG=~/.docker
      mkdir -p ${DOCKER_CONFIG}
      cp /workspace/docker-config.json ${DOCKER_CONFIG}/config.json

      # Change to directory with our .ko.yaml
      cd ${PROJECT_ROOT}

      # For each cmd/* directory, include a full gzipped tar of all source in
      # vendor/. This is overkill. Some deps' licenses require the source to be
      # included in the container image when they're used as a dependency.
      # Rather than trying to determine which deps have this requirement (and
      # probably get it wrong), we'll just targz up the whole vendor tree and
      # include it. As of 9/20/2019, this amounts to about 11MB of additional
      # data in each image.
      TMPDIR=$(mktemp -d)
      tar cfz ${TMPDIR}/source.tar.gz vendor/
      for d in cmd/*; do
        if [ -d ${d}/kodata/ ]; then
          ln -s ${TMPDIR}/source.tar.gz ${d}/kodata/
        fi
      done

      # Publish images and create release.yaml
      mkdir -p $OUTPUT_RELEASE_DIR

      # Make a local git tag to make git status happy :)
      # The real "tagging" will happen with the "create-release" pipeline.
      git tag $(params.versionTag)

      ko resolve \
        --image-label=org.opencontainers.image.source=https://$(params.package) \
        --platform=$(params.platforms) \
        -t $(params.versionTag) \
        -R ${KO_EXTRA_ARGS} \
        -f ${PROJECT_ROOT}/config/ > $OUTPUT_RELEASE_DIR/release.yaml
      # Publish images and create release.notags.yaml
      # This is useful if your container runtime doesn't support the `image-reference:tag@digest` notation
      # This is currently the case for `cri-o` (and most likely others)
      ko resolve \
        --image-label=org.opencontainers.image.source=https://$(params.package) \
        --platform=$(params.platforms) \
        -R ${KO_EXTRA_ARGS} \
        -f ${PROJECT_ROOT}/config/ > $OUTPUT_RELEASE_DIR/release.notags.yaml

      # Rewrite "devel" to params.versionTag
      sed -i -e 's/\(pipeline.tekton.dev\/release\): "devel"/\1: "$(params.versionTag)"/g' -e 's/\(app.kubernetes.io\/version\): "devel"/\1: "$(params.versionTag)"/g' -e 's/\(version\): "devel"/\1: "$(params.versionTag)"/g' ${OUTPUT_RELEASE_DIR}/release.yaml
      sed -i -e 's/\(pipeline.tekton.dev\/release\): "devel"/\1: "$(params.versionTag)"/g' -e 's/\(app.kubernetes.io\/version\): "devel"/\1: "$(params.versionTag)"/g' -e 's/\(version\): "devel"/\1: "$(params.versionTag)"/g' ${OUTPUT_RELEASE_DIR}/release.notags.yaml
  - name: koparse
    image: ghcr.io/tektoncd/plumbing/koparse@sha256:1898ef549aaff602d06c049136aaf1c1eacc573846c42bbf42d8dc9258235204
    script: |
      set -ex

      # Find "--preserve-import-paths" in a list of args
      function find_preserve_import_path() {
        for arg in $@; do
          if [[ "$arg" == "--preserve-import-paths" ]]; then
            return 0
          fi
        done
        return 1
      }

      # If "--preserve-import-paths" is used, include "package" in the expected path
      find_preserve_import_path \
        $(echo $KO_EXTRA_ARGS) && \
        PRESERVE_IMPORT_PATH="--preserve-path" || \
        PRESERVE_IMPORT_PATH="--no-preserve-path"

      for cmd in $(params.images)
      do
        IMAGES="${IMAGES} $(params.package)/cmd/${cmd}:$(params.versionTag)"
      done
      
      koparse --help 

      # Parse the built images from the release.yaml generated by ko
      koparse \
        --path $OUTPUT_RELEASE_DIR/release.yaml \
        --base $(params.package) \
        --container-registry ${CONTAINER_REGISTRY} \
        --images ${IMAGES} \
        ${PRESERVE_IMPORT_PATH} > /workspace/built_images

  - name: tag-images
    image: cgr.dev/chainguard/crane:latest-dev@sha256:430c7813147443b59185d79ce7f5d682698a9fc3072f100850dc3a04100c1d91
    script: |
      #!/bin/sh
      set -ex

      # Setup docker-auth
      DOCKER_CONFIG=~/.docker
      mkdir -p ${DOCKER_CONFIG}
      cp /workspace/docker-config.json ${DOCKER_CONFIG}/config.json

      # Tag the images and put them in all the regions
      for IMAGE in $(cat /workspace/built_images)
      do
        IMAGE_WITHOUT_SHA=${IMAGE%%@*}
        IMAGE_WITHOUT_SHA_AND_TAG=${IMAGE_WITHOUT_SHA%%:*}
        IMAGE_WITH_SHA=${IMAGE_WITHOUT_SHA_AND_TAG}@${IMAGE##*@}

        echo $IMAGE_WITH_SHA, >> $(results.IMAGES.path)

        if [[ "$(params.releaseAsLatest)" == "true" ]]
        then
          crane cp ${IMAGE_WITH_SHA} ${IMAGE_WITHOUT_SHA_AND_TAG}:latest
        fi

        for REGION in ${REGIONS}
        do
          if [[ "$(params.releaseAsLatest)" == "true" ]]
          then
            for TAG in "latest" $(params.versionTag)
            do
              crane cp ${IMAGE_WITH_SHA} ${REGION}.${IMAGE_WITHOUT_SHA_AND_TAG}:$TAG
            done
          else
            TAG="$(params.versionTag)"
            crane cp ${IMAGE_WITH_SHA} ${REGION}.${IMAGE_WITHOUT_SHA_AND_TAG}:$TAG
          fi
          # Until we are able to store larger results, we cannot include the
          # regional copies of the images in the result - see https://github.com/tektoncd/pipeline/issues/4282
          # echo ${REGION}.$IMAGE_WITH_SHA, >> $(results.IMAGES.path)
        done
      done