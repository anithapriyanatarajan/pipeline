name: Nightly Tekton Release

on:
  schedule:
    - cron: "0 3 * * *"
  workflow_dispatch:
  push:
    branches:
      - nightly-pipeline-gha

jobs:
  release:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        kubernetes_version: [v1.31.0]
    name: Nightly Pipeline Release (K8s ${{ matrix.kubernetes_version }})

    env:
      KUBERNETES_VERSION: ${{ matrix.kubernetes_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get latest commit from main
        id: latest
        run: |
          set -euo pipefail
          if [[ "${{ github.repository }}" == "tektoncd/pipeline" ]]; then
            REPO="https://github.com/tektoncd/pipeline.git"
            echo "üöÄ PRODUCTION MODE: Using upstream tektoncd/pipeline repository"
          else
            REPO="https://github.com/${{ github.repository }}.git"
            echo "üß™ FORK TESTING MODE: Using fork repository ${{ github.repository }}"
          fi
          sha=$(git ls-remote ${REPO} refs/heads/main | cut -f1)
          echo "sha=${sha}" >> "$GITHUB_OUTPUT"
          date_tag=$(date +v%Y%m%d-${sha:0:7})
          echo "versionTag=${date_tag}" >> "$GITHUB_OUTPUT"
          echo "Using SHA: ${sha}"
          echo "Version tag: ${date_tag}"

      - name: Set up Kind
        uses: helm/kind-action@v1.8.0
        with:
          node_image: kindest/node:${{ env.KUBERNETES_VERSION }}

      - name: Display Kubernetes Version
        run: |
          set -euo pipefail
          echo "üê≥ Kubernetes cluster version: ${{ env.KUBERNETES_VERSION }}"
          kubectl version --client
          kubectl version --short

      - name: Install Tekton Pipelines
        run: |
          set -euo pipefail
          kubectl apply -f https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
          kubectl wait deployment tekton-pipelines-controller -n tekton-pipelines --for=condition=Available=True --timeout=180s
          kubectl wait deployment tekton-pipelines-webhook -n tekton-pipelines --for=condition=Available=True --timeout=180s
          kubectl wait --for=condition=ready pod -l app=tekton-pipelines-webhook -n tekton-pipelines --timeout=180s
          kubectl logs -n tekton-pipelines -l app=tekton-pipelines-webhook
          echo "‚úÖ Tekton Pipelines installation completed"

      - name: Configure Tekton Git Resolver
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN || secrets.GHCR_TOKEN }}
        run: |
          set -euo pipefail
          echo "üîß Configuring Tekton Git resolver..."

          for i in {1..10}; do
            if kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io webhook.pipeline.tekton.dev >/dev/null 2>&1; then
              echo "‚úÖ Tekton webhook configuration found"
              break
            fi
            echo "‚è≥ Waiting for webhook configuration... (attempt $i/10)"
            sleep 5
          done
          
          # Create secret for Git resolver API token in both namespaces
          # 1. In tekton-pipelines-resolvers namespace for the Git resolver itself
          kubectl create secret generic git-resolver-secret \
            --from-literal=token="${GITHUB_TOKEN}" \
            -n tekton-pipelines-resolvers || echo "Secret may already exist in tekton-pipelines-resolvers"
          
          # 2. In default namespace for pipeline tasks that may need it
          kubectl create secret generic git-resolver-secret \
            --from-literal=token="${GITHUB_TOKEN}" \
            -n default || echo "Secret may already exist in default"
          
          # Enable resolvers in feature flags
          kubectl patch configmap resolvers-feature-flags -n tekton-pipelines-resolvers --patch='
          data:
            enable-git-resolver: "true"
            enable-hub-resolver: "true"
            enable-bundles-resolver: "true"
            enable-cluster-resolver: "true"
          ' || echo "ConfigMap may not exist yet"
          
          # Update git resolver config using kubectl patch
          kubectl patch configmap git-resolver-config -n tekton-pipelines-resolvers --patch='
          data:
            default-url: "https://github.com"
            default-revision: "main"
            fetch-timeout: "1m"
            scm-type: "github"
            server-url: "https://api.github.com"
            api-token-secret-name: "git-resolver-secret"
            api-token-secret-key: "token"
          '
          
          # Restart the resolvers to pick up the new configuration
          kubectl rollout restart deployment/tekton-pipelines-remote-resolvers -n tekton-pipelines-resolvers || echo "Resolvers deployment may not exist"
          
          # Wait for the restart to complete
          kubectl rollout status deployment/tekton-pipelines-remote-resolvers -n tekton-pipelines-resolvers --timeout=120s || echo "Timeout waiting for restart"
          
          # Give resolvers time to pick up the new config and be fully ready
          echo "‚è≥ Waiting for resolvers to be fully ready..."
          sleep 30
          
          # Verify resolver pods are running
          kubectl get pods -n tekton-pipelines-resolvers -l app.kubernetes.io/name=resolvers || echo "No resolver pods found"
          
          # Check if resolver service is accessible
          kubectl get services -n tekton-pipelines-resolvers || echo "No services in resolvers namespace"
          
          echo "‚úÖ Git resolver configured"

      - name: Debug Tekton Installation
        run: |
          set -euo pipefail
          echo "üîç Tekton Installation Debug Information"
          echo "============================================"
          
          echo "üì¶ Deployments in tekton-pipelines namespace:"
          kubectl get deployments -n tekton-pipelines -o wide
          
          echo "üì¶ Deployments in tekton-pipelines-resolvers namespace:"
          kubectl get deployments -n tekton-pipelines-resolvers -o wide || echo "No tekton-pipelines-resolvers namespace"
          
          echo "üèÉ Pods in tekton-pipelines namespace:"
          kubectl get pods -n tekton-pipelines -o wide
          
          echo "üèÉ Pods in tekton-pipelines-resolvers namespace:"
          kubectl get pods -n tekton-pipelines-resolvers -o wide || echo "No tekton-pipelines-resolvers namespace"
          
          echo "üåê Services in tekton-pipelines namespace:"
          kubectl get services -n tekton-pipelines
          
          echo "üìã ConfigMaps in tekton-pipelines-resolvers namespace:"
          kubectl get configmaps -n tekton-pipelines-resolvers || echo "No tekton-pipelines-resolvers namespace"
          
          echo "üîê Secrets in tekton-pipelines-resolvers namespace:"
          kubectl get secrets -n tekton-pipelines-resolvers | grep git-resolver || echo "No git-resolver secret found"
          
          echo "üîê Secrets in default namespace:"
          kubectl get secrets -n default | grep git-resolver || echo "No git-resolver secret found"
          
          echo "üéØ Webhook configurations:"
          kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io | grep tekton || echo "No Tekton webhooks found"
          
          echo "üìù Recent events in tekton-pipelines namespace:"
          kubectl get events -n tekton-pipelines --sort-by='.lastTimestamp' | tail -10 || echo "No events found"
          
          echo "üìù Recent events in tekton-pipelines-resolvers namespace:"
          kubectl get events -n tekton-pipelines-resolvers --sort-by='.lastTimestamp' | tail -10 || echo "No events found"
          
          echo "üîß Git resolver configuration:"
          kubectl get configmap git-resolver-config -n tekton-pipelines-resolvers -o yaml || echo "Git resolver config not found"
          
          echo "üèÅ Feature flags configuration:"
          kubectl get configmap resolvers-feature-flags -n tekton-pipelines-resolvers -o yaml || echo "Feature flags config not found"
          
          echo "üîç Resolver pod logs (if available):"
          kubectl logs -n tekton-pipelines-resolvers -l app.kubernetes.io/name=resolvers --tail=50 || echo "No resolver logs found"

      - name: Install tkn CLI
        run: |
          set -euo pipefail
          curl -sL https://github.com/tektoncd/cli/releases/download/v0.41.1/tkn_0.41.1_Linux_x86_64.tar.gz | tar xz
          sudo mv tkn /usr/local/bin/

      - name: Apply Nightly Pipeline Definition
        run: |
          set -euo pipefail
          for i in {1..10}; do
            if kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io webhook.pipeline.tekton.dev >/dev/null 2>&1; then
              echo "‚úÖ Tekton webhook configuration found"
              break
            fi
            echo "‚è≥ Waiting for webhook configuration... (attempt $i/10)"
            sleep 5
          done
          for i in {1..5}; do
            if kubectl apply -f tekton/release-nightly-pipeline.yaml; then
              echo "‚úÖ Pipeline applied successfully"
              break
            else
              echo "‚ö†Ô∏è  Failed to apply pipeline (attempt $i/5)"
              if [ $i -eq 5 ]; then
                echo "‚ùå Failed to apply pipeline after 5 attempts"
                exit 1
              fi
              echo "‚è≥ Waiting 10 seconds before retry..."
              sleep 10
            fi
          done
          kubectl get pipeline pipeline-release-nightly -o name
          echo "‚úÖ Pipeline verification completed"

      - name: List files in tekton directory
        run: ls -l tekton/

      - name: Test Git Resolver
        run: |
          set -euo pipefail
          echo "üß™ Testing Git resolver functionality..."
          
          # Extract org and repo from the package for testing
          if [[ "${{ github.repository }}" == "tektoncd/pipeline" ]]; then
            PACKAGE="github.com/tektoncd/pipeline"
          else
            PACKAGE="github.com/${{ github.repository }}"
          fi
          
          GIT_ORG=$(echo "${PACKAGE}" | cut -d'/' -f2)
          GIT_REPO=$(echo "${PACKAGE}" | cut -d'/' -f3)
          
          echo "Testing Git resolver with:"
          echo "  Org: ${GIT_ORG}"
          echo "  Repo: ${GIT_REPO}"
          echo "  Revision: ${{ steps.latest.outputs.sha }}"
          echo "  Path: tekton/publish.yaml"
          
          # Create a simple test task to verify Git resolver works
          cat << EOF > test-git-resolver.yaml
          apiVersion: tekton.dev/v1beta1
          kind: TaskRun
          metadata:
            name: test-git-resolver
          spec:
            taskRef:
              resolver: git
              params:
                - name: url
                  value: https://github.com/${GIT_ORG}/${GIT_REPO}.git
                - name: revision
                  value: ${{ steps.latest.outputs.sha }}
                - name: pathInRepo
                  value: tekton/publish.yaml
            params: []
          EOF
          
          echo "üìã Test TaskRun definition:"
          cat test-git-resolver.yaml
          
          echo "üöÄ Applying test TaskRun..."
          kubectl apply -f test-git-resolver.yaml
          
          echo "‚è≥ Waiting for TaskRun to complete..."
          kubectl wait taskrun test-git-resolver --for=condition=Succeeded=True --timeout=60s || {
            echo "‚ùå TaskRun failed or timed out"
            echo "TaskRun status:"
            kubectl describe taskrun test-git-resolver
            echo "TaskRun logs:"
            kubectl logs -l tekton.dev/taskRun=test-git-resolver || echo "No logs available"
            exit 1
          }
          
          echo "‚úÖ Git resolver test completed successfully"
          kubectl delete taskrun test-git-resolver

      - name: Create secrets and PVC template
        env:
          GCS_SERVICE_ACCOUNT_KEY: ${{ secrets.GCS_SERVICE_ACCOUNT_KEY }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          set -euo pipefail
          if [[ -z "${GCS_SERVICE_ACCOUNT_KEY}" ]]; then
            echo "‚ùå ERROR: GCS_SERVICE_ACCOUNT_KEY secret is not configured"
            exit 1
          fi
          if [[ -z "${GHCR_TOKEN}" ]]; then
            echo "‚ùå ERROR: GHCR_TOKEN secret is not configured"
            exit 1
          fi
          # Use plain echo, not base64 decoding
          echo "${GCS_SERVICE_ACCOUNT_KEY}" > /tmp/gcs-key.json
          kubectl create secret generic release-secret \
            --from-file=release.json=/tmp/gcs-key.json
          rm -f /tmp/gcs-key.json
          kubectl create secret docker-registry ghcr-creds \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password="${GHCR_TOKEN}" \
            --docker-email=${{ github.actor }}@users.noreply.github.com
          
          # Create workspace template for pipeline storage
          echo 'spec:' > workspace-template.yaml
          echo '  accessModes:' >> workspace-template.yaml
          echo '  - ReadWriteOnce' >> workspace-template.yaml
          echo '  resources:' >> workspace-template.yaml
          echo '    requests:' >> workspace-template.yaml
          echo '      storage: 1Gi' >> workspace-template.yaml
          
          # Verify the workspace template was created
          echo "üìù Workspace template created:"
          cat workspace-template.yaml

      - name: Start Nightly Tekton Pipeline
        run: |
          set -euo pipefail
          validate_param() {
            local param_name="$1"
            local param_value="$2"
            local pattern="$3"
            if [[ ! "${param_value}" =~ ${pattern} ]]; then
              echo "‚ùå ERROR: Invalid ${param_name}: ${param_value}"
              echo "Expected pattern: ${pattern}"
              exit 1
            fi
          }
          validate_param "gitRevision" "${{ steps.latest.outputs.sha }}" "^[a-f0-9]{40}$"
          validate_param "versionTag" "${{ steps.latest.outputs.versionTag }}" "^v[0-9]{8}-[a-f0-9]{7}$"
          if [[ "${{ github.repository }}" == "tektoncd/pipeline" ]]; then
            PACKAGE="github.com/tektoncd/pipeline"
            BUCKET="gs://tekton-releases-nightly/pipeline"
            REGISTRY_PATH="tekton-releases-nightly"
            REGISTRY_USER="tekton-robot"
            RUN_TESTS="true"
            RETENTION="30"
          else
            PACKAGE="github.com/${{ github.repository }}"
            BUCKET="gs://anitha-tekton-nightly-test/pipeline"
            REGISTRY_PATH="${{ github.repository_owner }}/pipeline-test"
            REGISTRY_USER="${{ github.actor }}"
            RUN_TESTS="false"
            RETENTION="7"
          fi
          validate_param "package" "${PACKAGE}" "^github\.com/[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$"
          validate_param "bucket" "${BUCKET}" "^gs://[a-zA-Z0-9][a-zA-Z0-9_.-]*[a-zA-Z0-9](/.*)?$"
          validate_param "registryPath" "${REGISTRY_PATH}" "^[a-zA-Z0-9][a-zA-Z0-9_.-]*[a-zA-Z0-9](/[a-zA-Z0-9_.-]+)*$"
          validate_param "retention" "${RETENTION}" "^[1-9][0-9]*$"
          
          # Extract org and repo from package (github.com/org/repo)
          GIT_ORG=$(echo "${PACKAGE}" | cut -d'/' -f2)
          GIT_REPO=$(echo "${PACKAGE}" | cut -d'/' -f3)
          validate_param "gitOrg" "${GIT_ORG}" "^[a-zA-Z0-9_.-]+$"
          validate_param "gitRepo" "${GIT_REPO}" "^[a-zA-Z0-9_.-]+$"
          
          echo "üîç Git parameters:"
          echo "   Package: ${PACKAGE}"
          echo "   Git Org: ${GIT_ORG}"
          echo "   Git Repo: ${GIT_REPO}"
          echo "   Git Revision: ${{ steps.latest.outputs.sha }}"
          echo "üöÄ Starting Tekton pipeline..."
          tkn pipeline list
          
          # Capture the pipeline start output
          PIPELINE_START_OUTPUT=$(tkn pipeline start pipeline-release-nightly \
            --param package="${PACKAGE}" \
            --param gitRevision="${{ steps.latest.outputs.sha }}" \
            --param gitOrg="${GIT_ORG}" \
            --param gitRepo="${GIT_REPO}" \
            --param versionTag="${{ steps.latest.outputs.versionTag }}" \
            --param releaseBucket="${BUCKET}" \
            --param imageRegistry=ghcr.io \
            --param imageRegistryPath="${REGISTRY_PATH}" \
            --param imageRegistryUser="${REGISTRY_USER}" \
            --param imageRegistryRegions="" \
            --param buildPlatforms="linux/amd64,linux/arm64,linux/s390x,linux/ppc64le" \
            --param publishPlatforms="linux/amd64,linux/arm64,linux/s390x,linux/ppc64le,windows/amd64" \
            --param koExtraArgs="--preserve-import-paths" \
            --param serviceAccountPath=release.json \
            --param serviceAccountImagesPath=credentials \
            --param runTests="${RUN_TESTS}" \
            --param retentionDays="${RETENTION}" \
            --workspace name=workarea,volumeClaimTemplateFile=workspace-template.yaml \
            --workspace name=release-secret,secret=release-secret \
            --workspace name=release-images-secret,secret=ghcr-creds \
            --pipeline-timeout 2h 2>&1)

          echo "üìã Pipeline start output:"
          echo "${PIPELINE_START_OUTPUT}"

          # Extract pipeline run name from the output - updated to match actual format
          PIPELINE_RUN=""
          if echo "${PIPELINE_START_OUTPUT}" | grep -q "PipelineRun started:"; then
            PIPELINE_RUN=$(echo "${PIPELINE_START_OUTPUT}" | grep "PipelineRun started:" | awk '{print $3}')
          elif echo "${PIPELINE_START_OUTPUT}" | grep -qE "pipeline-release-nightly-run-[a-z0-9]+"; then
            # Extract the pipeline run name directly from the output
            PIPELINE_RUN=$(echo "${PIPELINE_START_OUTPUT}" | grep -oE "pipeline-release-nightly-run-[a-z0-9]+" | head -n1)
          fi

          # If we still don't have a pipeline run name, try to get the latest one
          if [[ -z "${PIPELINE_RUN}" ]]; then
            echo "‚ö†Ô∏è  Could not extract pipeline run name from start output"
            echo "üîç Attempting to find the most recent pipeline run..."
            sleep 3  # Give it a moment to be created
            
            # Try multiple methods to get the pipeline run
            PIPELINE_RUN=$(tkn pipelinerun list --limit 1 -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            
            if [[ -z "${PIPELINE_RUN}" ]]; then
              PIPELINE_RUN=$(kubectl get pipelinerun -l tekton.dev/pipeline=pipeline-release-nightly --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null || echo "")
            fi
          fi

          if [[ -n "${PIPELINE_RUN}" ]]; then
            echo "‚úÖ Pipeline run captured: ${PIPELINE_RUN}"
            echo "PIPELINE_RUN=${PIPELINE_RUN}" >> $GITHUB_ENV
            
            # Verify the pipeline run exists
            if tkn pipelinerun describe "${PIPELINE_RUN}" >/dev/null 2>&1; then
              echo "‚úÖ Pipeline run verified and accessible"
            else
              echo "‚ö†Ô∏è  Pipeline run exists but may not be ready yet"
            fi
          else
            echo "‚ùå Failed to capture pipeline run name"
            echo "üîç Debug: Available pipeline runs:"
            tkn pipelinerun list || echo "No pipeline runs found"
            echo "üîç Debug: Kubernetes pipeline runs:"
            kubectl get pipelinerun -A || echo "No pipeline runs in cluster"
            
            # Don't exit here, let the monitoring step handle the empty pipeline run
            echo "PIPELINE_RUN=" >> $GITHUB_ENV
          fi

      - name: Monitor Pipeline Execution
        run: |
          set -euo pipefail
          if [ -n "${PIPELINE_RUN:-}" ]; then
            echo "üìä Monitoring pipeline execution: ${PIPELINE_RUN}"
            tkn pipelinerun logs ${PIPELINE_RUN} --follow || {
              echo "‚ö†Ô∏è  Log following failed, showing status instead"
              tkn pipelinerun describe ${PIPELINE_RUN}
            }
          else
            echo "‚ùå No pipeline run to monitor"
          fi

      - name: Show Pipeline Results
        if: always()
        run: |
          set -euo pipefail
          echo "üìä Pipeline Execution Results"
          echo "Pipeline run: ${PIPELINE_RUN:-}"
          if [ -n "${PIPELINE_RUN:-}" ]; then
            tkn pipelinerun describe ${PIPELINE_RUN} || true
            tkn pipelinerun logs ${PIPELINE_RUN} --follow=false || true
            if [[ "${{ github.repository }}" != "tektoncd/pipeline" ]]; then
              echo ""
              echo "üß™ FORK TESTING RESULTS:"
              echo "   ‚úÖ Pipeline structure validated"
              echo "   ‚úÖ Real secrets used for testing"
              echo "   üì¶ Artifacts published to test bucket: gs://anitha-tekton-nightly-test/pipeline"
              echo "   üê≥ Container images published to: ghcr.io/${{ github.repository_owner }}/pipeline-test"
              echo "   üîç Check logs above for complete pipeline validation"
            fi
          else
            echo "‚ùå Pipeline run name not captured - check pipeline start step"
          fi